#!/usr/bin/env python3
from __future__ import annotations

import json
import re
from datetime import datetime, timezone
from pathlib import Path
from urllib.request import Request, urlopen
import html as _html

BOX_URL = "https://celestrak.org/satcat/boxscore.php"
OUT_PATH = Path(__file__).resolve().parents[1] / "data" / "tracked_total.json"


def fetch_boxscore_html() -> str:
    req = Request(BOX_URL, headers={"User-Agent": "ORA/0.6 (+https://erikherrera00.github.io/orbital-risk-authority)"})
    with urlopen(req, timeout=30) as r:
        return r.read().decode("utf-8", errors="replace")


def extract_all_totals(html_text: str) -> dict:
    """
    Robustly parse SATCAT boxscore totals:
    Find the <tr> row that corresponds to the "All" totals row and extract numbers from it.
    """
    s = _html.unescape(html_text)

    # Find all table rows
    rows = re.findall(r"<tr\b[^>]*>.*?</tr\s*>", s, flags=re.I | re.S)

    best = None
    best_nums = None

    for tr in rows:
        # Strip tags -> plain text for quick inspection
        plain = re.sub(r"<[^>]+>", " ", tr)
        plain = plain.replace("\xa0", " ")
        plain = re.sub(r"\s+", " ", plain).strip()

        # Look for the "All" totals row (usually starts with "All")
        # Sometimes it's exactly "All" in the first cell, so allow "All" at start or surrounded.
        if not re.search(r"(^|\s)All(\s|$)", plain, flags=re.I):
            continue

        # Extract all numeric tokens from this row
        nums = [int(x.replace(",", "")) for x in re.findall(r"\d[\d,]*", plain)]

        # The totals row should include 10 numbers:
        # Payloads (3) + Debris (4) + All (3) = 10
        if len(nums) == 10:
            best = plain
            best_nums = nums
            break

        # Keep a fallback: sometimes extra numbers appear; accept >=10 and take the last 10
        if len(nums) > 10 and best is None:
            best = plain
            best_nums = nums[-10:]

    if not best or not best_nums:
        # Helpful debug: show a few candidate rows mentioning "All"
        candidates = []
        for tr in rows:
            plain = re.sub(r"<[^>]+>", " ", tr)
            plain = plain.replace("\xa0", " ")
            plain = re.sub(r"\s+", " ", plain).strip()
            if re.search(r"(^|\s)All(\s|$)", plain, flags=re.I):
                candidates.append(plain[:200])
        raise RuntimeError(
            "Could not find 'All' totals row in SATCAT boxscore.\n"
            "Candidate rows containing 'All' (first 10):\n" + "\n".join(candidates[:10])
        )

    nums = best_nums
    payloads_on_orbit, payloads_decayed, payloads_total = nums[0], nums[1], nums[2]
    debris_active, debris_on_orbit, debris_decayed, debris_total = nums[3], nums[4], nums[5], nums[6]
    all_on_orbit, all_decayed, all_total = nums[7], nums[8], nums[9]

    return {
        "data_source": "CelesTrak SATCAT Boxscore (All sources aggregate)",
        "snapshot_time_utc": datetime.now(timezone.utc).replace(microsecond=0).isoformat().replace("+00:00", "Z"),
        "tracked_objects_total": all_total,
        "tracked_objects_on_orbit": all_on_orbit,
        "payloads_on_orbit": payloads_on_orbit,
        "debris_on_orbit": debris_on_orbit,
        "debris_active": debris_active,
        "notes": "Generated by backend/tools/update_tracked_totals.py. Source: CelesTrak SATCAT Boxscore.",
    }


def main() -> int:
    html = fetch_boxscore_html()
    totals = extract_all_totals(html)

    OUT_PATH.parent.mkdir(parents=True, exist_ok=True)
    OUT_PATH.write_text(json.dumps(totals, indent=2) + "\n", encoding="utf-8")

    print("âœ… Updated tracked totals:")
    print(f"   path: {OUT_PATH}")
    print(f"   tracked_objects_total: {totals['tracked_objects_total']:,}")
    print(f"   tracked_objects_on_orbit: {totals['tracked_objects_on_orbit']:,}")
    print(f"   payloads_on_orbit: {totals['payloads_on_orbit']:,}")
    print(f"   debris_on_orbit: {totals['debris_on_orbit']:,}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main())

